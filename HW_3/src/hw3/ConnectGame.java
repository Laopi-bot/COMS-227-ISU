package hw3;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Random;

import api.ScoreUpdateListener;
import api.ShowDialogListener;
import api.Tile;

/**
 * Class that models a game.
 */
public class ConnectGame {
	private ShowDialogListener dialogListener;
	private ScoreUpdateListener scoreListener;

	/**
	 * minimum level the tile can be
	 */
	private int minimumLevel = 0;

	/**
	 * maximum level the tile can be
	 */
	private int maximumLevel = 0;

	/**
	 * height of the grid
	 */
	private int gridHeight = 0;

	/**
	 * width of the grid
	 */
	private int gridWidth = 0;

	/**
	 * score of the game
	 */
	private long score = 0;

	/*
	 * set to true if the user has already selected their first tile to start
	 * matching
	 */
	private boolean isAlreadySelecting = false;

	/**
	 * random generator based on given value in connectGame constructor
	 */
	private Random rand = null;

	/**
	 * random number generated by getRandomTile()
	 */
	private int randomNum = 0;

	/**
	 * ArrayList to hold selected tiles
	 */
	private ArrayList<Tile> selectedTiles = new ArrayList<Tile>();

	/**
	 * the grid to be used in the methods
	 */
	private Grid grid = null;

	/**
	 * Constructs a new ConnectGame object with given grid dimensions and minimum
	 * and maximum tile levels.
	 * 
	 * @param width  grid width
	 * @param height grid height
	 * @param min    minimum tile level
	 * @param max    maximum tile level
	 * @param rand   random number generator
	 */
	public ConnectGame(int width, int height, int min, int max, Random rand) {
		grid = new Grid(width, height);
		gridHeight = height;
		gridWidth = width;
		minimumLevel = min;
		maximumLevel = max;
		this.rand = rand;
	}

	/**
	 * Gets a random tile with level between minimum tile level inclusive and
	 * maximum tile level exclusive. For example, if minimum is 1 and maximum is 4,
	 * the random tile can be either 1, 2, or 3.
	 * <p>
	 * DO NOT RETURN TILES WITH MAXIMUM LEVEL
	 * 
	 * @return a tile with random level between minimum inclusive and maximum
	 *         exclusive
	 */
	public Tile getRandomTile() {
		randomNum = this.rand.nextInt(maximumLevel - minimumLevel) + minimumLevel;
		return new Tile(randomNum);
	}

	/**
	 * Regenerates the grid with all random tiles produced by getRandomTile().
	 */
	public void radomizeTiles() {
		// loop that calls getRandomTile
		for (int i = 0; i < gridWidth; i++) {
			for (int j = 0; j < gridHeight; j++) {
				grid.setTile(getRandomTile(), i, j);
			}
		}
	}

	/**
	 * Determines if two tiles are adjacent to each other. The may be next to each
	 * other horizontally, vertically, or diagonally.
	 * 
	 * @param t1 one of the two tiles
	 * @param t2 one of the two tiles
	 * @return true if they are next to each other horizontally, vertically, or
	 *         diagonally on the grid, false otherwise
	 */
	public boolean isAdjacent(Tile t1, Tile t2) {
		// goes through and checks for each case of adjacency
		// this feels very inefficient and i kinda ran out of time to conceptualize a
		// better idea
		// horizontal check
		if ((t1.getX() + 1 == t2.getX() && t1.getY() == t2.getY())
				|| (t2.getX() + 1 == t1.getX() && t1.getY() == t2.getY())) {
			return true;
		}
		// vertical check
		if ((t1.getY() + 1 == t2.getY() && t1.getX() == t2.getX())
				|| (t1.getY() - 1 == t2.getY() && t1.getX() == t2.getX())) {
			return true;
		}
		// diagonal check

		// top right
		if (((t1.getY() - 1 == t2.getY()) && (t1.getX() + 1 == t2.getX())) ||
		// top left
				((t1.getY() - 1 == t2.getY()) && (t1.getX() - 1 == t2.getX())) ||
				// bottom right
				((t1.getY() + 1 == t2.getY()) && (t1.getX() + 1 == t2.getX())) ||
				// bottom left
				((t1.getY() + 1 == t2.getY()) && (t1.getX() - 1 == t2.getX()))) {
			return true;
		}
		return false;
	}

	/**
	 * Indicates the user is trying to select (clicked on) a tile to start a new
	 * selection of tiles.
	 * <p>
	 * If a selection of tiles is already in progress, the method should do nothing
	 * and return false.
	 * <p>
	 * If a selection is not already in progress (this is the first tile selected),
	 * then start a new selection of tiles and return true.
	 * 
	 * @param x the column of the tile selected
	 * @param y the row of the tile selected
	 * @return true if this is the first tile selected, otherwise false
	 */
	public boolean tryFirstSelect(int x, int y) {
		// go into if statement if the person isn't already selecting a tile
		if (!isAlreadySelecting) {
			// add and set to true
			selectedTiles.add(grid.getTile(x, y));
			grid.getTile(x, y).setSelect(true);
			isAlreadySelecting = true;
			return true;
		}
		// if they are already selecting, return false
		return false;
	}

	/**
	 * Indicates the user is trying to select (mouse over) a tile to add to the
	 * selected sequence of tiles. The rules of a sequence of tiles are:
	 * 
	 * <pre>
	 * 1. The first two tiles must have the same level.
	 * 2. After the first two, each tile must have the same level or one greater than the level of the previous tile.
	 * </pre>
	 * 
	 * For example, given the sequence: 1, 1, 2, 2, 2, 3. The next selected tile
	 * could be a 3 or a 4. If the use tries to select an invalid tile, the method
	 * should do nothing. If the user selects a valid tile, the tile should be added
	 * to the list of selected tiles.
	 * 
	 * @param x the column of the tile selected
	 * @param y the row of the tile selected
	 */
	public void tryContinueSelect(int x, int y) {
		if (isAlreadySelecting) {
			// main adding bracket
			if (isAdjacent(selectedTiles.get(selectedTiles.size() - 1), grid.getTile(x, y))) {
				// get level of tile to add and last tile in the already added list
				int tileToAddLevel = grid.getTile(x, y).getLevel();
				int previousTileLevel = selectedTiles.get(selectedTiles.size() - 1).getLevel();

				// if statements for adding the second tile to the selected list
				if (selectedTiles.size() == 1) {
					if (previousTileLevel == tileToAddLevel) {
						selectedTiles.add(grid.getTile(x, y));
						grid.getTile(x, y).setSelect(true);
					}
				} else { // if there is already more than one tile in the selected list
					if (tileToAddLevel == previousTileLevel || tileToAddLevel == previousTileLevel + 1) {
						selectedTiles.add(grid.getTile(x, y));
						grid.getTile(x, y).setSelect(true);
					}
				}

				// chunk of code to unselect a tile if the newest entry in selectedTiles is
				// equal to the second to last entry in selectedTiles
				if (selectedTiles.size() > 2 && x == selectedTiles.get(selectedTiles.size() - 2).getX()
						&& y == selectedTiles.get(selectedTiles.size() - 2).getY()) {
					// gets the x and y values of the last selected tile in the array list of
					// selected tiles and removes it from the list
					unselect(selectedTiles.get(selectedTiles.size() - 1).getX(),
							selectedTiles.get(selectedTiles.size() - 1).getY());
				}
			}
		}
	}

	/**
	 * Indicates the user is trying to finish selecting (click on) a sequence of
	 * tiles. If the method is not called for the last selected tile, it should do
	 * nothing and return false. Otherwise it should do the following:
	 * 
	 * <pre>
	 * 1. When the selection contains only 1 tile reset the selection and make sure all tiles selected is set to false.
	 * 2. When the selection contains more than one block:
	 *     a. Upgrade the last selected tiles with upgradeLastSelectedTile().
	 *     b. Drop all other selected tiles with dropSelected().
	 *     c. Reset the selection and make sure all tiles selected is set to false.
	 * </pre>
	 * 
	 * @param x the column of the tile selected
	 * @param y the row of the tile selected
	 * @return return false if the tile was not selected, otherwise return true
	 */
	public boolean tryFinishSelection(int x, int y) {
		// check if the last tile in the selected tiles is equal to the tile's
		// coordinates that were put into the method
		if (isAlreadySelecting) {
			if (selectedTiles.get(selectedTiles.size() - 1) == grid.getTile(x, y)) {

				// case for if the selection contains only one tile
				if (selectedTiles.size() == 1) {
					selectedTiles.get(0).setSelect(false);
					selectedTiles.clear();
					isAlreadySelecting = false;
				}

				// case for if selection contains more than one tile
				if (selectedTiles.size() > 1) {

					// iterate through list and update score
					for (int i = 0; i < selectedTiles.size(); i++) {
						score += selectedTiles.get(i).getValue();
					}
					scoreListener.updateScore(score);

					// Upgrade the last selected tile with upgradeLastSelectedTile()
					upgradeLastSelectedTile();
					// drop the tiles above the selected tiles with dropSelected()
					dropSelected();

					// unselects all selected tiles
					for (int i = 0; i < selectedTiles.size(); i++) {
						selectedTiles.get(i).setSelect(false);
					}

					// clears selected tiles and allows for selecting the first tile again
					selectedTiles.clear();
					isAlreadySelecting = false;
				}
				return true;
			}
		}
		return false;
	}

	/**
	 * Increases the level of the last selected tile by 1 and removes that tile from
	 * the list of selected tiles. The tile itself should be set to unselected.
	 * <p>
	 * If the upgrade results in a tile that is greater than the current maximum
	 * tile level, both the minimum and maximum tile level are increased by 1. A
	 * message dialog should also be displayed with the message "New block 32,
	 * removing blocks 2". Not that the message shows tile values and not levels.
	 * Display a message is performed with dialogListener.showDialog("Hello,
	 * World!");
	 */
	public void upgradeLastSelectedTile() {
		// increases the level of the last selected tile
		selectedTiles.get(selectedTiles.size() - 1)
				.setLevel((selectedTiles.get(selectedTiles.size() - 1).getLevel()) + 1);
		// changes min and max if level is above current max and prints out new dialog.
		// also drops the tiles of the level below the current new level
		if (selectedTiles.get(selectedTiles.size() - 1).getLevel() > maximumLevel) {
			maximumLevel++;
			//new block dialogue
			dialogListener.showDialog(
					"New block " + Math.pow(2, maximumLevel) + " removing blocks " + Math.pow(2, minimumLevel));
			minimumLevel++;
			dropLevel(minimumLevel - 1);
		}
		// unselects tile and removes it from list
		selectedTiles.get(selectedTiles.size() - 1).setSelect(false);
		selectedTiles.remove(selectedTiles.size() - 1);
	}

	/**
	 * Gets the selected tiles in the form of an array. This does not mean selected
	 * tiles must be stored in this class as a array.
	 * 
	 * @return the selected tiles in the form of an array
	 */
	public Tile[] getSelectedAsArray() {
		Tile[] selectedTilesAsArray = (Tile[]) selectedTiles.toArray(new Tile[0]);
		return selectedTilesAsArray;
	}

	/**
	 * Removes all tiles of a particular level from the grid. When a tile is
	 * removed, the tiles above it drop down one spot and a new random tile is
	 * placed at the top of the grid.
	 * 
	 * @param level the level of tile to remove
	 */
	public void dropLevel(int level) {
		for (int i = 0; i < gridWidth; i++) {
			for (int j = 0; j < gridHeight; j++) {
				// checks if current tile being iterated through is of the level that was
				// provided. if it is, go into another for loop that counts how
				// many tiles are above it, and places each tile above it one size down, adding
				// one random at the top, because there will only ever need to be one random added at a time
				if (grid.getTile(i, j).getLevel() == level) {
					for (int k = j; k >= 0; k--) {
						// adds random tile at top of array
						if (k == 0) {
							grid.setTile(getRandomTile(), i, k);
							break;
						}
						// sets current tile to be equal to the one above it
						grid.setTile(grid.getTile(i, k - 1), i, k);
					}
				}
			}
		}
	}

	/**
	 * Removes all selected tiles from the grid. When a tile is removed, the tiles
	 * above it drop down one spot and a new random tile is placed at the top of the
	 * grid.
	 */
	public void dropSelected() {
		/*
		 * search through the whole array when we reach a tile that is to be removed we
		 * enter another for loop that gets the amount of tiles above it and set the
		 * loop equal to five times that
		 */
		for (int i = 0; i < gridWidth; i++) {
			for (int j = 0; j < gridHeight; j++) {
				// checks if current tile being iterated through is selected. if it is, go into
				// another for loop that counts how
				// many tiles are above it, and places each tile above it one size down, adding
				// one random at the top, because there will only ever need to be one random added at a time
				if (grid.getTile(i, j).isSelected()) {
					for (int k = j; k >= 0; k--) {
						// adds random tile at top of array
						if (k == 0) {
							grid.setTile(getRandomTile(), i, k);
							break;
						}
						// sets current tile to be equal to the one above it
						grid.setTile(grid.getTile(i, k - 1), i, k);
					}
				}
			}
		}
	}

	/**
	 * Remove the tile from the selected tiles.
	 * 
	 * @param x column of the tile
	 * @param y row of the tile
	 */
	public void unselect(int x, int y) {
		// remove value from arrayList of selected tiles and set its slection status to false
		selectedTiles.remove(grid.getTile(x, y));
		grid.getTile(x, y).setSelect(false);
	}

	/**
	 * Gets the player's score.
	 * 
	 * @return the score
	 */
	public long getScore() {
		return score;
	}

	/**
	 * Gets the game grid.
	 * 
	 * @return the grid
	 */
	public Grid getGrid() {
		return grid;
	}

	/**
	 * Gets the maximum tile level.
	 * 
	 * @return the maximum tile level
	 */
	public int getMaxTileLevel() {
		int maxTileLevel = 0;
		for (int i = 0; i < gridWidth; i++) {
			for (int j = 0; j < gridHeight; j++) {
				// if the current tile level is greater than the current max, set that as the
				// new max
				if (grid.getTile(i, j).getLevel() > maxTileLevel) {
					maxTileLevel = grid.getTile(i, j).getLevel();
				}
			}
		}
		return maxTileLevel;
	}

	/**
	 * Gets the minimum tile level.
	 * 
	 * @return the minimum tile level
	 */
	public int getMinTileLevel() {
		return minimumLevel;
	}

	/**
	 * Sets the player's score.
	 * 
	 * @param score number of points
	 */
	public void setScore(long score) {
		this.score = score;
		scoreListener.updateScore(score);
	}

	/**
	 * Sets the game's grid.
	 * 
	 * @param grid game's grid
	 */
	public void setGrid(Grid grid) {
		this.grid = grid;
	}

	/**
	 * Sets the minimum tile level.
	 * 
	 * @param minTileLevel the lowest level tile
	 */
	public void setMinTileLevel(int minTileLevel) {
		this.minimumLevel = minTileLevel;
	}

	/**
	 * Sets the maximum tile level.
	 * 
	 * @param maxTileLevel the highest level tile
	 */
	public void setMaxTileLevel(int maxTileLevel) {
		this.maximumLevel = maxTileLevel;
	}

	/**
	 * Sets callback listeners for game events.
	 * 
	 * @param dialogListener listener for creating a user dialog
	 * @param scoreListener  listener for updating the player's score
	 */
	public void setListeners(ShowDialogListener dialogListener, ScoreUpdateListener scoreListener) {
		this.dialogListener = dialogListener;
		this.scoreListener = scoreListener;
	}

	/**
	 * Save the game to the given file path.
	 * 
	 * @param filePath location of file to save
	 */
	public void save(String filePath) {
		GameFileUtil.save(filePath, this);
	}

	/**
	 * Load the game from the given file path
	 * 
	 * @param filePath location of file to load
	 * @throws FileNotFoundException
	 */
	public void load(String filePath) throws FileNotFoundException {
		GameFileUtil.load(filePath, this);
	}
}
